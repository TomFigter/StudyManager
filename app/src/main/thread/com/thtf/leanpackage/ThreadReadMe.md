   
                                                   多线程
                                           ---------------------
                                           |   Android消息机制  |
                                           ---------------------
                                           |       线程锁       |
                                           ---------------------
                                           |       线程池       |
                                           ---------------------
                                           |     线程回调接口    |
                                           ---------------------
                                           |    线程Other特质    |
                                           ----------------------
====================================================================================================   
   
&Android 消息机制
 |__问题
 |   |-> 1.系统如何将消息投递到消息队列中? 又是如何从消息队列中获取消息并且处理消息的呢?
 |   |     > 最终都由Handler去实现; Handler将一个消息Post到UI线程中,然后再在Handler的handleManage方法中处理. 
 |   |       Handler就是一个消息处理器
 |   |
 |   |-> 2.Handler为什么必须在主线程中创建?
 |   |     > 每个Handler都会关联一个消息队列,消息队列被封装在Looper中;而每个Looper又会关联一个线程(Looper通过
 |   |       ThreadLocal封装),最终是每个消息队列会关联一个线程.
 |   |
 |   |-> 3.消息队列如何创建启动的?
 |   |     > 默认情况下,消息队列只有一个;即主线程的消息队列,这个消息队列是在ActivityThread.main方法中创建通过
 |   |       Lopper.prepareMainLooper()来创建.最后执行Looper.loop()来启动消息循环.
 |   |
 |   |-> 4.Handler是如何关联消息队列以及线程的呢?
 |   |     > Handler会在内部通过Looper.getLooper()来获取Looper对象,即与消息队列关联了.而在prepare()中创建了
 |   |       一个Looper对象,并将该对象设置给了sThreadLocal.即队列与线程关联上了;所以Handler关联了两者.
 |   |
 |   |-> 5.在子线程中创建Handler为何抛出异常?
 |   |     > Looper对象是ThreadLoad的,每个线程都由自己的Looper,并且Looper允许为空;当在子线程中创建Handler时
 |   |       若Looper为null即会抛出异常.因为Handler需与MessageQueue建立关联,而MessageQueue被封装在Looper中
 |   |       因此创建Handler时Looper不可为空.而在子线程中创建Handler的解决方法:
 |   |       
 |   |        new Thread(){
 |   |               Handler handler=null;
 |   |               public void run(){
 |   |                    //1.为当前线程通过Looper,并且会绑定到ThreadLocal中
 |   |                    Looper.prepare();
 |   |                    handler=new Handler();
 |   |                    //2.启动消息队列
 |   |                    Looper.loop();
 |   |               } ;
 |   |         }.start()
 |   |
 ---------------------------------------------------------------------------------------------------

&线程回调接口
 |__Callable
 |__Future
 |__FutureTask
 |---------------
 |___特质
 |   <1> 另外三者只能运用到线程池中,而Runnable既能运用到Thread又能用于线程池中
 |   <2> Callable与Runnable功能大致相同,而Callable具有返回值call()而Runnable无返回值
 |   <3> Callable与Runnable运行状态下不可控.而Future为线程池制定了一个可管理的任务标准
 |   <4> FutureTask既是Future,Runnable又包装了Callable.它是两者的结合体
 ---------------------------------------------------------------------------------------------------

&线程池
 |__特质
 |  <1> 重用存在的线程,减少对象的创建、销毁的开销.
 |  <2> 可有效控制最大并发线程数,提高系统资源的使用率,同时避免过多资源竞争,避免阻塞.
 |  <3> 提供定时执行、定期执行、单线程、并发数控制等功能.
 ---------------------------------------------------------------------------------------------------
 
&线程Other特质
 |__同步集合
 |
 @___CopyOnWriteArrayList | CopyOnWriteArraySet  程序优化策略
 |_____特性
 |      -> 多线程共享同一个列表,当某个线程要修改这个列表的元素时,会把列表中的元素Copy一份,然后进行修改;修改完成
 |         完成后再将新的元素设置给这个列表,这是一种延时懒惰策略.而CopyOnWrite并发读不需要加锁,即读写分离的思想
 |         读和写不同容器.(P87)
 |--------------------------------------------------------------------------------------------------
 @___ConcurrentHashMap  提高并发率
 |____特性
 |     -> HashTable是HashMap的线程安全实现,但HashTable容器使用的是Synchronized来保证线程安全,但在线程竞争激烈
 |        的情况下,HashTable效率非常低;所以ConcurrentHashMap采用了分段加锁技术,首先经数据分成一段一段的存储,然
 |        后给每一段数据配一把锁,当一个线程占用锁访问其中一个段数据时,其他段数据也能被其他线程访问.
 |--------------------------------------------------------------------------------------------------
 @___BlockingQueue  有效方法
 |   |__ArrayBlockingQueue  ---> FIFO (先进先出) 单向链表实现的阻塞队列
 |   |  |-> 是数组实现的、线程安全的、有界的阻塞队列.内部通过"互斥锁"保护竞争资源.
 |--------------------------------------------------------------------------------------------------
 |   |__LinkedBlockingQueue ---> FIFO (先进先出) 单向链表实现的阻塞队列
 |   |__LinkedBlockingDeque ---> FIFO/FILO (先进先出/先进后出) 双向链表实现的阻塞队列
 |   |__ConcurrentLinkedQueue
 |____特性
 |     -> 
 ---------------------------------------------------------------------------------------------------
 
&线程锁
 |   
 |__#显示锁--ReentrantLock 与 Condition
 |   
 |___特性
 |    -> ReentrantLock与内置锁Synchronized相比具有更高的灵活性
 |	     > 内置锁Synchronized的获取和释放都放在同一个代码块中,而显示锁则可以将锁的获取和释放公开
 |	     > 显示锁提供轮训锁和定时锁
 |       > 可以提供公平锁或非公平锁
 |	
 |___问题
 |	  -> 为什么Lock没有替代掉Synchronized?
 |	     > Lock需要在finally()块中手动释放锁,而Synchronized由JVM确保锁会被自动释放
 |	     > 当JVM用Synchronized管理锁请求和释放时,JVM在生成线程转储时能够包括锁的信息,这对调试非常有价值
 |   	   因为它能标识死锁或其他异常行为的来源;而Lock只是普通类,JVM不知具体哪个线程拥有Lock对象.
 |	
 |___ReentrantLock--Condition
 |    -> newCondition()函数用于获取Lock上的一个条件,也就是说Condition是用于Lock绑定的.
 |	  -> Condition用于实现线程间的通信,它是为了解决Object.wait()/notify()/notifyAll()难以使用的问题   
 |	
 |___实例
 |    -> 我们创建了一个LockThreadBlockingQueue阻塞队列.当队列元素为最大容量时,若再向队列添加元素
 |    -> 会调用notFull.await()函数使得调用线程阻塞.
 |    -> 直到其他线程调用take()函数,即从该队列中取了元素后才会唤醒该线程.因为此时的队列不再是已满状态
 |    -> 所以可以调用notFull.signalAll()唤醒等待线程,使得可以继续添加元素操作。
 ---------------------------------------------------------------------------------------------------
 |__#限号量--Semaphore
 |
 |___定义
 |    -> Semaphore是一个技术信号量,它的本质是一个"共享锁".信号量维护一个信号量许可集,线程可以通过调用
 |	  -> acquire()来获取信号量的许可,线程可以通过release()来释放它所持有的信号量许可.
 |    -> 当信号量中有可用的许可时,线程能获取该许可;否则线程必须等待,直到有可用的许可为止.
 ---------------------------------------------------------------------------------------------------	
 |__#同步辅助类
 |	
 |___#循环栅栏--CyclicBarrier
 |    允许一组线程相互等待,直到达到某个公共屏障点. 
 |    barrier在释放等待线程后可重用,所以称他为循环的barrier.
 |___#闭锁--CountDownLatch
 |    在完成一组正在其他线程中执行的操作之前,它允许一个或多个线程一直等待.指定允许执行的线程数,当此时执行的线程数
 |    不足于指定的线程数,则此时需执行的线程数会处于等待的状态,直到与指定的线程数相等才进行执行.
 @___CountDownLatch与CyclicBarrier不同点
 |    -> CountDownLatch的作用允许1个或N个线程等待其他线程完成执行,而CyclicBarrier则是允许N个线程相互等待.
 |    -> CountDownLatch的技术器无法被重置,CyclicBarrier的计数器可以被重置后使用;因此它被称为循环的barrier.
 ---------------------------------------------------------------------------------------------------
 
 